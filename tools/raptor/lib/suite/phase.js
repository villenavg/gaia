var EventEmitter = require('events').EventEmitter;
var Promise = require('promise');
var util = require('util');
var merge = require('deepmerge');
var Dispatcher = require('../dispatcher');
var helpers = require('../helpers');
var MozDevice = require('mozdevice');
var report = require('../reporter');
var stats = require('stats-lite');
require('console.table');

var TAG_IDENTIFIER = 'persist.raptor.';

/**
 * Base suite runner. Functionality which is common to all runners should be
 * accessible here
 * @param {{
 *   runs: Number,
 *   timeout: Number,
 *   retries: Number,
 *   preventDispatching: Boolean,
 *   emulator: Boolean
 * }} options
 * @constructor
 */
var Phase = function(options) {
  EventEmitter.call(this);

  this.title = 'Raptor';
  this.runs = [];
  this.results = [];
  this.formattedRuns = [];
  this.time = options.time || Date.now();
  this.options = merge({
    timeout: options.emulator ? 150 * 1000 : 60 * 1000,
    retries: 1,
    runs: 1,
    launchDelay: 10 * 1000
  }, options);

  if (process.env.TIMEOUT) {
    this.options.timeout = process.env.TIMEOUT;
  }

  if (process.env.LAUNCH_DELAY) {
    this.options.launchDelay = process.env.LAUNCH_DELAY;
  }

  this.log('Preparing to start testing...');
  this.resetTimeout();
};

util.inherits(Phase, EventEmitter);

Phase.prototype.GRID_ORIGIN_Y = 110;

Phase.prototype.log = function() {
  var args = Array.prototype.slice.call(arguments);

  args.splice(1, 0, this.title);
  args[0] = '[%s] ' + arguments[0];

  console.log.apply(console, args);
};

/**
 * Emit an error if a test run times out
 */
Phase.prototype.timeoutError = function() {
  this.emit('error', new Error('Test timeout exceeded ' +
    this.options.timeout + 'ms'));
};

/**
 * Halt handling of a test run timeout
 */
Phase.prototype.stopTimeout = function() {
  if (this.timeout) {
    clearTimeout(this.timeout);
  }
};

/**
 * Restart the timeout timer and optionally specify a function to run on timeout
 * @param {function} [handler]
 */
Phase.prototype.resetTimeout = function(handler) {
  var runner = this;

  this.stopTimeout();
  this.timeout = setTimeout(handler || function() {
    runner.timeoutError();
  }, this.options.timeout);
};

/**
 * Store any entries generated by parsers of a given <eventType>
 * @param {string} eventType
 */
Phase.prototype.capture = function(eventType) {
  var runner = this;
  this.dispatcher.on(eventType, function(entry) {
    runner.results.push(entry);
  });
};

/**
 * Register a parser to be able to handle incoming log messages
 * @param {function} parser
 */
Phase.prototype.registerParser = function(parser) {
  this.dispatcher.registerParser(parser);
};

/**
 * Report time-series data
 * @param {object} data
 * @returns {Promise}
 */
Phase.prototype.report = function(data) {
  var runner = this;

  return report(data)
    .then(function() {
      runner.canReport = true;
    });
};

/**
 * Read an manifest.webapp file as an object
 * @param {string} path
 * @returns {object}
 */
Phase.prototype.requireManifest = function(path) {
  return helpers.requireJSON(path);
};

/**
 * Resolve when a device is ready for user interaction, e.g. tapping, swiping
 * @returns {Promise}
 */
Phase.prototype.getDevice = function() {
  var runner = this;

  if (this.device) {
    return Promise.resolve(this.device);
  }

  return new Promise(function(resolve, reject) {
    var callback = function(err, device) {
      if (err) {
        return runner.emit('error', err);
      }

      runner.device = device;

      // Allow specific runners to handle their own Dispatcher set up
      if (!runner.options.preventDispatching) {
        device.log.start();
        runner.dispatcher = new Dispatcher(device);
      }

      resolve(device);
    };

    return process.env.ANDROID_SERIAL ?
      MozDevice(process.env.ANDROID_SERIAL, callback) :
      MozDevice(callback);
  });
};

/**
 * Attempt to perform a test run
 * @returns {Promise}
 */
Phase.prototype.tryRun = function() {
  var runner = this;

  return new Promise(function(resolve, reject) {
    runner.resetTimeout(function() {
      reject(new Error('timeout'));
    });

    runner
      .testRun()
      .then(resolve, reject);
  });
};

/**
 * Handler to be invoked when the current run is completed and ready for another
 * run or end of suite. Continuation is passed to the test itself for next
 * determination.
 */
Phase.prototype.next = function() {
  var runner = this;
  var rejectError = function(err) {
    runner.emit('error', err);
  };

  this.stopTimeout();
  this.log('Run %d complete', this.currentRun);

  this.runs.push(this.results);

  if (this.currentRun < this.options.runs) {
    // If we have more runs to do, notify the tester that the current run has
    // completed and pass a function which will start the next run...
    this.currentRun++;
    this.emit('run', function() {
      runner.handleRun()
        .then(function() {
          runner.test();
        }, rejectError);
    });
  } else {
    // ...otherwise notify the tester that the current run has completed and
    // pass a function which will end the test suite
    this.emit('run', function() {
      runner.handleRun()
        .then(function() {
          runner.emit('end');
          runner.removeAllListeners();
          runner.dispatcher.end();
        }, rejectError);
    });
  }
};

/**
 * Handle a test run failure by attempting any retries or notifying the test
 * runner of the failure
 * @param err
 */
Phase.prototype.fail = function(err) {
  var runner = this;

  this.stopTimeout();

  if (err.message && err.message === 'timeout') {
    if (this.currentTry <= this.options.retries) {
      this.log('Run %d timed out, retry attempt %d',
        this.currentRun, this.currentTry);
      this.currentTry++;

      // reset the timer and any potentially erroneous results
      this.resetTimeout();
      this.results = [];

      this.device.log
        .clear()
        .then(function() {
          return runner.retry();
        })
        .then(function() {
          return runner.tryRun();
        })
        .then(function() {
          runner.next();
        }, function(err) {
          runner.fail(err);
        });
    } else {
      this.timeoutError();
    }
  } else {
    runner.emit('error', err);
  }
};

/**
 * Start a single test run
 */
Phase.prototype.test = function() {
  var runner = this;

  this.log('Starting run %d', this.currentRun);

  this.results = [];

  this
    .tryRun()
    .then(function() {
      runner.next();
    }, function(err) {
      runner.fail(err);
    });
};

/**
 * Input event will be ignored if the value equals to the kernel cached one.
 * Initiate a reset to set cached values 0 after a B2G restart. Check bug
 * 1168269 commment 22 for more information.
 * @returns {Promise}
 */
Phase.prototype.resetInput = function() {
  return this.device.input.reset();
};

/**
 * Start the suite by passing execution back to the runner for event binding and
 * test notifications
 */
Phase.prototype.start = function() {
  var runner = this;

  this.currentRun = 1;
  this.currentTry = 1;

  // Force async execution to allow binding of events before test starts
  setTimeout(function() {
    runner.emit('ready');
    runner.test();
  });
};

/**
 * Write the given entries to a format suitable for reporting
 * @param {Array} entries
 * @param {String} suite
 * @param {String} startMark
 * @returns {object}
 */
Phase.prototype.format = function(entries, suite, startMark) {
  var runner = this;
  var results = {};
  var deviceAction = null;
  var deviceActionIndex = null;

  // Find the deviceAction and its location in the entries
  entries.every(function(entry, index) {
    if (entry.name === startMark) {
      deviceAction = entry;
      deviceActionIndex = index;
      return false;
    }

    return true;
  });

  // Remove deviceAction from the other entries so we can save another filtering
  entries.splice(deviceActionIndex, 1);

  entries.forEach(function(entry) {
    var name = entry.name;
    var series = suite + '.' + name;
    var point = {
      time: runner.time,
      suite: suite,
      entryType: entry.entryType,
      context: entry.context
    };

    if (entry.appName) {
      point.appName = entry.appName;
    }

    if ('value' in entry) {
      point.value = entry.value;
    } else {
      point.epoch = entry.epoch;
      point.value = entry.entryType === 'mark' ?
        entry.epoch - deviceAction.epoch : entry.duration;
    }

    if (point.value < 0) {
      return;
    }

    point = merge(point, runner.getDeviceTags());

    if (!results[series]) {
      results[series] = [];
    }

    results[series].push(point);
  });

  this.formattedRuns.push(results);

  return results;
};

/**
 * Output aggregate statistical information for all suite runs to the console
 */
Phase.prototype.logStats = function() {
  var runner = this;
  var results = {};

  this.formattedRuns.forEach(function(run) {
    Object
      .keys(run)
      .forEach(function(key) {
        var entry = run[key][0];
        var contextResults = results[entry.context];

        if (!contextResults) {
          contextResults = results[entry.context] = {};
        }

        if (!contextResults[key]) {
          contextResults[key] = [];
        }

        var value = entry.value;

        if (entry.entryType === 'memory') {
          value = value / 1024 / 1024;
        }

        contextResults[key].push(value);
      });
  });

  Object
    .keys(results)
    .forEach(function(contextKey) {
      var contextResults = results[contextKey];
      var metrics = [];

      Object
        .keys(contextResults)
        .forEach(function(key) {
          var values = contextResults[key];
          var percentile = stats.percentile(values, 0.95);

          metrics.push({
            Metric: key,
            Mean: stats.mean(values).toFixed(3),
            Median: stats.median(values).toFixed(3),
            Min: Math.min.apply(Math, values).toFixed(3),
            Max: Math.max.apply(Math, values).toFixed(3),
            StdDev: stats.stdev(values).toFixed(3),
            p95: percentile ? percentile.toFixed(3) : 'n/a'
          });
        });

        runner.log('Results from %s\n', contextKey);
        console.table(metrics);
      });
};

/**
 * Read device-specific tags from the device's properties
 * @returns {object}
 */
Phase.prototype.getDeviceTags = function() {
  if (this.getDeviceTags.cache) {
    return this.getDeviceTags.cache;
  }

  var properties = this.device.properties;
  var tags = {};

  Object
    .keys(properties)
    .forEach(function(key) {
      if (key.indexOf(TAG_IDENTIFIER) === 0) {
        tags[key.slice(TAG_IDENTIFIER.length)] = properties[key];
      }
    });

  return this.getDeviceTags.cache = tags;
};

/**
 * Report event metadata used for writing annotations to Raptor visualization UI
 * @returns {Promise}
 */
Phase.prototype.reportTest = function() {
  if (!this.canReport) {
    return Promise.resolve();
  }

  // TODO: Evaluate the necessity of writing data this way once we switch to...
  // TODO: ...using Grafana 2.0 or InfluxDB 1.9
  var text = util.format('Gaia: %s<br/>Gecko: %s',
    this.device.gaiaRevision.substr(0, 16),
    this.device.geckoRevision.substr(0, 16));

  var row = merge({
    time: this.time,
    title: 'Revisions',
    tags: null,
    text: text
  }, this.getDeviceTags());

  return this.report({
    events: [row]
  });
};

module.exports = Phase;
